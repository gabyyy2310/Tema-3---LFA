#Tema 3 - LFA - Pirvulescu Gabriela - 151

#we define our grammar
productions = {
    "S": ["aSb", ""]
}  #producions are represented in a dictionary
non_terminals = {"S"}
terminals = {"a", "b"}
start_symbol = "S"

#string generator
def generate_strings(symbol="S", max_len=10):
    def generate(current, depth=0):
        if len(current.replace("S", "")) > max_len or depth > max_len:
            return set()
        if "S" not in current:
            return {current}
        results = set()
        for production in productions["S"]:
            new_str = current.replace("S", production, 1)
            results.update(generate(new_str, depth + 1))
        return results

    return sorted(generate("S"), key=lambda x: (len(x), x)) #we want the strings to be diplayed in lenght order


#derivation
def derivation_steps(target, current="S", steps=None):
    if steps is None:
        steps = ["S"]
    if current == target:
        return steps
    if len(current.replace("S", "")) > len(target):
        return None
    if "S" not in current:
        return None
    for production in productions["S"]:
        next_current = current.replace("S", production, 1)
        result = derivation_steps(target, next_current, steps + [next_current])
        if result:
            return result
    return None

#we test now if a string is generated by the cfg
def is_generated(string, current="S"):
    if current == "":
        return string == ""
    if current[0] in terminals:
        return string and current[0] == string[0] and is_generated(string[1:], current[1:])
    elif current[0] in non_terminals:
        for production in productions[current[0]]:
            if is_generated(string, production + current[1:]):
                return True
    return False

productions_abc = {
    "S": ["S1", "S2", "S3", "S4", "S5", ""],
    "S1": ["a b c"],
    "S2": ["a a b b c c"],
    "S3": ["a a a b b b c c c"],
    "S4": ["a a a a b b b b c c c c"],
    "S5": ["a a a a a b b b b b c c c c c"]
}

non_terminals_abc = set(productions_abc.keys())

def generate_anbncn_strings(symbol="S", max_len=15):
    def generate(current, depth=0):
        if len(current) > max_len or depth > max_len:
            return set()
        if all(sym not in non_terminals_abc for sym in current):
            return {"".join(current)}
        results = set()
        for i, sym in enumerate(current):
            if sym in non_terminals_abc:
                for prod in productions_abc[sym]:
                    new_symbols = prod.split()  # split string into list of symbols
                    new_str = current[:i] + new_symbols + current[i+1:]
                    results.update(generate(new_str, depth + 1))
                break
        return results

    return sorted(generate([symbol]), key=lambda x: (len(x), x))

def is_abc(string):
    if string in generate_anbncn_strings(symbol="S", max_len=15):
        return True
    return False

print("Generated strings:")
print(generate_strings())

print("\nDerivation steps for 'aabb':")
steps = derivation_steps("aabb")
if steps:
        print(" => ".join(steps))
else:
    print("No derivation found.")

print("\nMembership tests:")
for s in ["aabb", "ab", "aaabbb", "abab", "aaaaaaabbbbbbb"]:
    print(f"{s}: {is_generated(s)}")

print("\nGenerated abc strings: ")
print(generate_anbncn_strings())
print(is_abc("aaaabbbbcccc"))

